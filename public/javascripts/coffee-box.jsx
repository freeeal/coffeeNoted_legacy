// native HTML element names start w/ lowercase, while custom React class names start with uppercase letters
// creating Coffee component, which will depend on data passed in from its parent (CoffeeList)
var Coffee = React.createClass({
	render: function() {
		return {
			<div className="coffee">
				// access named attributes passed to the component as keys on this.props and any nested elements as this.props.children
				<h2 className="coffeeAuthor">
					{this.props.author}
				</h2>
				{this.props.children}
			</div>
		}
	}
})

var CoffeeBox = React.createClass({
	loadCoffeesFromServer: function() {
		// AJAX call when the component is first loaded and every 2 seconds after that. 
    	$.ajax({
	      url: this.props.url,
	      dataType: 'json',
	      cache: false,
	      success: function(data) {
	        this.setState({data: data}); // this.state is private to the component and can be changed by calling this.setState(), which re-renders itself once the state updates
	      }.bind(this),
	      error: function(xhr, status, err) {
	        console.error(this.props.url, status, err.toString());
	      }.bind(this)
	    });
  	},
  	handleCoffeeSubmit: function(coffee) {
  		// var coffees = this.state.data;
  		// Optimistically set an id on the new comment. It will be replaced by an
    	// id generated by the server. In a production application you would likely
    	// not use Date.now() for this and would have a more robust system in place.
  		// var newCoffees = coffees.concat([coffee]);
  		// this.setState({data: newCoffees});
    	// submit to the server and refresh the list
    	$.ajax({
	      url: this.props.url,
	      dataType: 'json',
	      type: 'POST',
	      data: coffee,
	      success: function(data) {
	        this.setState({data: data});
	      }.bind(this),
	      error: function(xhr, status, err) {
	      	// this.setState({data: coffees});
	        console.error(this.props.url, status, err.toString());
	      }.bind(this)
	    });
  	},
	getInitialState: function() {
		return {data: []};
	},
	componentDidMount: function() {
    	this.loadCoffeesFromServer();
    	setInterval(this.loadCoffeesFromServer, this.props.pollInterval);
  	},
	// render returns a tree of React components that will eventually render to HTML
	render: function() {
		return (
			// <div> tags are not DOM nodes, but are instantiations of React 'div' components
			// HTML components are just regular React components, BUT
			// here, the JSX compiler will auto rewrite HTML tags to React.createElement(tagName) expressions and leave everything else alone
			// thus preventing global namespace pollution
			<div className="coffeeBox">
				<h1>Coffees</h1>
				<CoffeeList data={this.state.data} />
				<CoffeeForm onCoffeeSubmit={this.handleCoffeeSubmit} /> 
				// CoffeeBox makes callback available to CoffeeForm via the onCoffeeSubmit prop and so the CoffeeForm can call the callback when the user submits the form
			</div>
		);
	}
});

// props are immutable: for reactive state, need to introduce mutable state of the component
var CoffeeList = React.createClass({
	render: function() {
		var coffeeNodes = this.props.data.map(function(coffee) {
			return (
				// passing data from parent CoffeeList to child Coffee components, dynamically rendered
				<Coffee author={coffee.author} key={coffee.id}>
					{coffee.text}
				</Coffee>
			);
		});
		return ()
			<div className="coffeeList">
				{coffeeNodes}
			</div>
		);
	}
});

var CoffeeForm = React.createClass({
	getInitialState: function() {
		return {author: '', text: ''};
	},
	handleAuthorChange: function(e) {
		this.setState({author: e.target.value});
	},
	handleTextChange: function(e) {
    	this.setState({text: e.target.value});
  	},
  	handleSubmit: function(e) {
	    e.preventDefault(); // prevent browser's default action on submitting the form
	    var author = this.state.author.trim();
	    var text = this.state.text.trim();
	    if (!text || !author) {
	      return;
	    }
	    // send request to the server
	    this.props.onCoffeeSubmit({author: author, text: text});
	    this.setState({author: '', text: ''});
  	},
	render: function() {
		return (
	      <form className="coffeeForm" onSubmit={this.handleSubmit}>
	        <input
	          type="text"
	          placeholder="Your name"
	          value={this.state.author}
	          onChange={this.handleAuthorChange}
        	/>
       		<input
	          type="text"
	          placeholder="Say something..."
	          value={this.state.text}
	          onChange={this.handleTextChange}
        	/>
	        <input type="submit" value="POST" />
	      </form>
   	 	);
	}
});

// ReactDOM.render() instantiates the root component, starts the framework, and injects the markup into a raw DOM element, provided as the second argument.
// must remain at bottom of script -- after composite components have been defined
ReactDOM.render(
	<CoffeeBox data="/users/:username" pollInterval={2000} />,
	document.getElementById('content')
);